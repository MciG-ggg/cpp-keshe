# 商场停车场管理系统技术文档

## 1. 系统架构概述

### 1.1 整体架构
系统采用前后端分离的架构设计：

- 前端：HTML + CSS + JavaScript
- 后端：C++ RESTful API服务器
- 数据存储：文件系统（parking_data.dat）

### 1.2 核心功能模块
- 车辆管理：入场、出场登记
- 费用计算：基于车型和停车时长
- 状态监控：实时车位统计
- 历史记录：停车记录查询

## 2. 前后端数据交互

### 2.1 API接口设计

#### 2.1.1 车辆入场
- 接口：POST /api/vehicle
- 请求数据：
```json
{
    "plate": "车牌号",
    "type": "车辆类型"
}
```
- 响应数据：
```json
{
    "success": true/false,
    "message": "操作结果描述"
}
```

#### 2.1.2 车辆出场
- 接口：DELETE /api/vehicle/{车牌号}
- 响应数据：
```json
{
    "success": true/false,
    "message": "操作结果描述",
    "data": {
        "plate": "车牌号",
        "type": "车辆类型",
        "fee": 费用金额
    }
}
```

#### 2.1.3 状态查询
- 接口：GET /api/status
- 响应数据：
```json
{
    "success": true,
    "data": {
        "available": 可用车位数,
        "occupied": 已占用车位数
    }
}
```

#### 2.1.4 历史记录查询
- 接口：GET /api/history
- 响应数据：
```json
{
    "success": true,
    "data": [
        {
            "plate": "车牌号",
            "type": "车辆类型",
            "entryTime": 入场时间戳,
            "exitTime": 出场时间戳,
            "fee": 费用金额
        }
    ]
}
```

### 2.2 前端实现细节

#### 2.2.1 API调用封装
前端通过 `api.js` 封装所有API调用：
```javascript
const ParkingAPI = {
    async addVehicle(plate, type) {
        // 发送POST请求处理车辆入场
    },
    async removeVehicle(plate) {
        // 发送DELETE请求处理车辆出场
    }
    // ...其他API封装
};
```

#### 2.2.2 实时数据更新
- 使用定时轮询更新停车场状态
- 采用事件监听处理用户操作
- 异步处理所有API请求

### 2.3 后端实现细节

#### 2.3.1 请求处理流程
1. 接收HTTP请求
2. 解析请求参数
3. 调用业务逻辑
4. 返回JSON响应

#### 2.3.2 并发处理
- 使用多线程处理并发请求
- 线程安全的数据访问控制
- 异常处理机制

## 3. 数据存储与读取

### 3.1 数据持久化方案

#### 3.1.1 文件存储结构
- 使用二进制文件 parking_data.dat 存储数据
- 包含车辆信息、费率设置等数据
- 采用序列化方式存储数据结构

#### 3.1.2 数据读写操作
- 程序启动时自动加载数据
- 数据变更时实时写入
- 程序退出时确保数据保存

### 3.2 数据安全性保障
- 文件操作异常处理
- 数据完整性校验
- 并发访问控制

### 3.3 数据备份机制
- 定期自动备份
- 数据恢复机制
- 日志记录功能

## 4. 系统优化与扩展

### 4.1 性能优化
- API响应时间优化
- 数据存取效率提升
- 内存使用优化

### 4.2 可扩展性设计
- 模块化的代码结构
- 可配置的系统参数
- 插件式的功能扩展

### 4.3 安全性增强
- 输入数据验证
- URL编码处理
- CORS跨域控制
- 异常处理机制

## 5. 调试与维护

### 5.1 调试工具
- 前端控制台调试
- API测试脚本
- 日志监控

### 5.2 常见问题处理
- 连接异常处理
- 数据同步问题
- 并发访问问题

## 6. 部署说明

### 6.1 环境要求
- Linux操作系统
- G++ 编译器 (C++17)
- Make构建工具

### 6.2 部署步骤
1. 编译后端服务
2. 配置服务参数
3. 启动服务程序
4. 访问Web界面

## 具体实现
让我通过查看代码来详细解释前后端数据交互和数据存储的具体实现。我来详细解释前后端数据交互和数据存储的具体实现：

1. **前端实现 (Frontend)**
- api.js 中封装了所有与后端的API交互，包括：
  ```javascript
  - addVehicle(plate, type)    // 车辆入场
  - removeVehicle(plate)       // 车辆出场
  - queryVehicle(plate)        // 查询车辆信息
  - getParkingStatus()         // 获取停车场状态
  - updateRates()              // 更新费率
  - getHistory()              // 获取历史记录
  ```
- 采用现代的 `async/await` 异步处理方式
- 统一的错误处理机制
- 所有请求都使用标准的 RESTful 风格

2. **后端实现 (Backend)**
在 api_server.cpp 中：
- 使用多线程处理并发请求
- 实现了完整的 HTTP 请求解析和响应生成
- 支持 CORS 跨域请求
- 支持静态文件服务

主要处理函数包括：
```cpp
- handleAddVehicle()      // 处理入场请求
- handleRemoveVehicle()   // 处理出场请求
- handleQueryVehicle()    // 处理查询请求
- handleGetParkingStatus() // 处理状态查询
- handleGetHistory()      // 处理历史记录查询
```

3. **数据存储实现**
- 采用二进制文件 parking_data.dat 进行持久化存储
- 文件操作设计：
  ```cpp
  - 程序启动时从文件加载数据
  - 数据变更时实时写入文件
  - 使用文件锁保证并发安全
  - 定期自动备份机制
  ```

4. **数据交互流程**
以车辆入场为例：
```
前端 → 后端 → 数据存储的完整流程：
1. 用户在前端输入车牌号和车型
2. api.js 中的 addVehicle() 发送 POST 请求
3. 后端 api_server.cpp 接收并解析请求
4. parking_lot.cpp 处理业务逻辑
5. 数据写入 parking_data.dat
6. 返回处理结果给前端
7. 前端更新界面显示
```

5. **安全性设计**
- URL编码处理防止注入
- 输入数据验证
- CORS安全控制
- 文件操作异常处理
- 并发访问控制

这个项目采用了现代化的前后端分离架构，数据交互清晰，存储机制可靠，并考虑了并发、安全等关键因素。完整的API接口设计和数据持久化方案使系统具有良好的可扩展性和可维护性。

---
# 各模块语法

---
# JavaScript 异步函数语法解析

## 1. 异步函数声明
```javascript
async addVehicle(plate, type)
```
- `async`: 声明这是一个异步函数，允许在函数内使用 `await` 关键字
- `addVehicle`: 函数名
- `plate, type`: 函数参数，分别接收车牌号和车型

## 2. Fetch API 调用
```javascript
const response = await fetch(`${CONFIG.API_BASE_URL}/vehicle`, {
    method: 'POST',
    headers: {
        'Content-Type': 'application/json',
    },
    body: JSON.stringify({ plate, type })
});
```
- ```${CONFIG.API_BASE_URL}```: 模板字符串语法，用于动态拼接API地址
- `fetch()`: 浏览器原生的网络请求API
- `await`: 等待异步操作完成
- 请求配置对象包含：
  - `method: 'POST'`: HTTP请求方法
  - `headers`: 设置请求头
  - `body`: 请求体，使用`JSON.stringify()`将对象转换为JSON字符串

## 3. 错误处理
```javascript
try {
    // 请求代码
} catch (error) {
    console.error('Error adding vehicle:', error);
    throw error;
}
```
- `try/catch`: 异常捕获语法
- `console.error()`: 在控制台输出错误信息
- `throw error`: 向上层抛出错误

## 4. 响应处理
```javascript
return await response.json();
```
- `response.json()`: 将响应解析为JSON对象
- `await`: 等待解析完成
- `return`: 返回解析后的数据

## 实际使用示例
```javascript
// 调用示例
try {
    const result = await ParkingAPI.addVehicle('京A12345', 'small');
    console.log('车辆添加成功:', result);
} catch (error) {
    console.error('车辆添加失败:', error);
}
```

---
# JavaScript Fetch API 详解

Fetch API 是现代浏览器提供的一种原生网络请求接口，用于替代传统的 XMLHttpRequest。它提供了一个更简单、更强大的方式来进行网络请求。

## 1. 基本用法
```javascript
fetch(url, options)
  .then(response => response.json())
  .catch(error => console.error('Error:', error));
```

## 2. 主要特点

1. **Promise 基础**
- 返回 Promise 对象
- 支持 async/await 语法
- 链式调用处理响应

2. **请求配置选项**
```javascript
const options = {
    method: 'POST',          // 请求方法
    headers: {               // 请求头
        'Content-Type': 'application/json'
    },
    body: JSON.stringify(data), // 请求体
    mode: 'cors',           // 跨域模式
    credentials: 'include', // 凭证处理
}
```

3. **响应处理方法**
```javascript
response.json()    // 解析JSON响应
response.text()    // 获取文本响应
response.blob()    // 处理二进制数据
response.formData() // 处理表单数据
```

## 3. 实际应用示例

### GET 请求
```javascript
// 基本GET请求
fetch('https://api.example.com/data')
    .then(response => response.json())
    .then(data => console.log(data));

// 带参数的GET请求
fetch('https://api.example.com/data?id=123')
    .then(response => response.json());
```

### POST 请求
```javascript
fetch('https://api.example.com/data', {
    method: 'POST',
    headers: {
        'Content-Type': 'application/json',
    },
    body: JSON.stringify({
        name: 'test',
        value: 123
    })
});
```

### 使用 async/await
```javascript
async function getData() {
    try {
        const response = await fetch('https://api.example.com/data');
        const data = await response.json();
        return data;
    } catch (error) {
        console.error('Error:', error);
    }
}
```

## 4. 错误处理
- fetch 只有在网络错误时才会 reject
- HTTP 错误状态（如 404）不会导致 reject
- 需要手动检查 response.ok 或 response.status

```javascript
fetch('https://api.example.com/data')
    .then(response => {
        if (!response.ok) {
            throw new Error('HTTP错误，状态码: ' + response.status);
        }
        return response.json();
    })
    .catch(error => console.error('错误:', error));
```

## 5. 与 XMLHttpRequest 比较
- Fetch 语法更简洁
- 基于 Promise，支持链式调用
- 更好的模块化支持
- 原生支持 JSON
- 更强大的请求控制能力

---
## 后端相关(api_server.cpp)
好的,我来详细讲解后端相关的关键文件和涉及的知识。首先让我查看主要的后端文件：让我详细讲解后端的关键文件和重要知识点：

1. **API服务器实现 (api_server.cpp/h)**
- HTTP服务器的核心实现，包含以下关键知识：

```cpp
class ParkingApiServer {
    // Socket编程基础
    int serverSocket;  // 服务器socket
    bool running;      // 服务器运行状态
    
    // 智能指针管理资源
    std::unique_ptr<ParkingLot> parkingLot;
    
    // API路由处理函数
    HttpResponse handleAddVehicle(const HttpRequest& req);
    HttpResponse handleRemoveVehicle(const HttpRequest& req);
    // ...其他处理函数
};
```

重要知识点：
- Socket网络编程：创建socket、绑定端口、监听连接
- 多线程并发处理：每个客户端请求都在新线程中处理
- HTTP协议实现：请求解析、响应生成
- CORS跨域处理：设置跨域头部
- 异常处理：try-catch错误处理机制
- 智能指针：使用unique_ptr管理资源

2. **停车场业务逻辑 (parking_lot.cpp/h)**
核心业务类，处理：
- 车辆管理（增删改查）
- 费用计算
- 数据持久化

重要知识点：
- STL容器使用：
```cpp
std::map<std::string, Vehicle> vehicles;  // 存储车辆信息
std::vector<Vehicle> getHistoryVehicles() const;  // 返回历史记录
```
- 文件IO操作：二进制文件读写
- const成员函数：保证数据安全
- 数据序列化：对象持久化到文件

3. **数据持久化实现**
在parking_lot.cpp中：
```cpp
bool ParkingLot::saveData() const {
    std::ofstream outFile(dataFilePath, std::ios::binary);
    // 写入元数据（容量、费率等）
    // 写入车辆数据
}

bool ParkingLot::loadData() {
    std::ifstream inFile(dataFilePath, std::ios::binary);
    // 读取元数据
    // 读取车辆数据
}
```

重要知识点：
- 二进制文件操作
- 数据序列化/反序列化
- 类型安全的数据读写

4. **线程安全考虑**
```cpp
std::thread([this, clientSocket]() {
    // 在新线程中处理请求
    try {
        HttpRequest request = parseRequest(clientSocket);
        // 处理请求...
    } catch (...) {
        // 错误处理
    }
}).detach();
```

重要知识点：
- 多线程编程
- Lambda表达式
- RAII资源管理
- 异常安全

5. **C++11/17特性使用**
- 智能指针
- Lambda表达式
- 文件系统操作(std::filesystem)
- 范围for循环
- auto类型推导

6. **HTTP协议实现**
```cpp
class HttpRequest {
    std::string method;     // GET, POST等
    std::string path;       // 请求路径
    std::string body;       // 请求体
    std::map<std::string, std::string> params;  // 请求参数
};

class HttpResponse {
    int status;            // 状态码
    std::string body;      // 响应体
    std::map<std::string, std::string> headers;  // 响应头
};
```

这个实现展示了：
- HTTP协议的基本概念
- RESTful API设计
- 请求/响应的处理流程
- 错误处理机制

要掌握这个项目的后端实现，需要理解：
1. C++面向对象编程
2. STL容器和算法
3. 网络编程基础（Socket）
4. HTTP协议
5. 多线程编程
6. 文件IO操作
7. 现代C++特性

---
我来详细介绍这个停车场管理系统的系统结构。从架构上看，这是一个典型的前后端分离的 Web 应用程序。让我用 ASCII 图来展示系统的整体架构：

```
+-------------------------+        HTTP        +-------------------------+
|      Frontend (Web)     |<----------------->|      Backend (C++)      |
|                        |     请求/响应      |                         |
+-------------------------+                   +-------------------------+
| - HTML/CSS/JavaScript  |                   | - Socket HTTP Server    |
|                        |                   | - RESTful API          |
| 组件:                   |                   | 组件:                   |
| ├── index.html        |                   | ├── ParkingApiServer   |
| ├── style.css         |                   | ├── ParkingLot        |
| └── JavaScript        |                   | └── Vehicle           |
|     ├── api.js        |                   |                         |
|     ├── config.js     |                   | 数据持久化:              |
|     └── main.js       |                   | └── parking_data.dat   |
+-------------------------+                   +-------------------------+
        ⬆                                              ⬆
        |                                              |
        |            +------------------+              |
        |            |    用户界面       |              |
        +------------+  - 车辆入场/出场   +--------------+
                     |  - 状态显示       |
                     |  - 费用计算       |
                     +------------------+
```

数据流向图：
```
用户操作 ➜ 前端界面 ➜ API调用 ➜ 后端服务器 ➜ 业务逻辑 ➜ 数据持久化
  ⬆                                                        |
  +------------------------响应数据------------------------+
```

详细架构说明：

1. **前端层 (Frontend)**
```
src/frontend/
├── index.html          # 主页面
├── css/
│   └── style.css      # 样式定义
└── js/
    ├── config.js      # 配置信息
    ├── api.js         # API封装
    └── main.js        # 业务逻辑
```

2. **后端层 (Backend)**
```
src/backend/
├── api_server.cpp/h    # HTTP服务器和API实现
├── parking_lot.cpp/h   # 停车场业务逻辑
├── vehicle.cpp/h       # 车辆信息管理
└── main.cpp           # 程序入口
```

3. **核心交互流程**:

```
[用户] → [前端界面] → [API调用] → [后端服务] → [数据处理] → [持久化]
  ↑          ↑           ↓           ↓           ↓          ↓
  └──────────┴───────响应数据───────返回结果────数据查询───存储文件
```

4. **主要功能模块**:

```
+---------------+      +---------------+      +---------------+
|   用户界面层    |      |   业务逻辑层   |      |   数据存储层   |
+---------------+      +---------------+      +---------------+
| - 车辆入场登记  |      | - 车位管理     |      | - 文件读写    |
| - 车辆出场结算  | →    | - 费用计算     | →    | - 数据序列化  |
| - 状态实时显示  |      | - 记录管理     |      | - 持久化存储  |
| - 历史记录查询  |      | - 费率设置     |      | - 并发控制    |
+---------------+      +---------------+      +---------------+
```

5. **技术栈详解**:

前端技术：
- HTML5：页面结构
- CSS3：样式布局（响应式设计）
- JavaScript：
  - Fetch API：异步请求
  - DOM操作：界面更新
  - Event handling：事件处理

后端技术：
- C++ 17
- Socket编程：HTTP服务器
- 多线程并发处理
- 文件IO：数据持久化
- STL容器：数据管理

6. **数据流处理**:

入场流程示例：
```
[用户输入] → [前端验证] → [API请求] → [后端验证] → [数据处理] → [持久化]
   ↓            ↓           ↓           ↓           ↓          ↓
车牌号码  →  格式检查  → POST请求 →  参数校验  →  添加记录  → 保存文件
车辆类型  →  完整性    → JSON数据 →  业务检查  →  更新状态  → 
```

这种架构设计的优点：
1. 前后端分离，便于开发和维护
2. RESTful API设计，接口清晰
3. 数据持久化方案简单可靠
4. 多线程处理并发请求
5. 实时数据更新机制
6. 完整的错误处理和异常机制

扩展性考虑：
1. 可以方便地添加新的API端点
2. 支持不同类型的客户端接入
3. 可以轻松扩展数据存储方式
4. 支持配置化的参数调整
5. 预留了功能扩展接口

---
# 计算机网络基础

## 1. 网络分层模型 (OSI七层模型和TCP/IP四层模型)

```
OSI七层                TCP/IP四层
+-------------+      +-------------+
| 应用层      |      |            |
| 表示层      |  →   | 应用层      | (HTTP, FTP, SMTP)
| 会话层      |      |            |
+-------------+      +-------------+
| 传输层      |  →   | 传输层      | (TCP, UDP)
+-------------+      +-------------+
| 网络层      |  →   | 网络层      | (IP)
+-------------+      +-------------+
| 数据链路层   |      |            |
| 物理层      |  →   | 网络接口层   | (以太网)
+-------------+      +-------------+
```

## 2. 重要协议介绍

### 2.1 TCP (传输控制协议)
```
特点：
- 面向连接
- 可靠传输
- 流量控制
- 拥塞控制

三次握手：
Client                Server
  |     SYN=1         |
  | ----------------> |
  |   SYN=1, ACK=1   |
  | <---------------- |
  |     ACK=1        |
  | ----------------> |
```

### 2.2 UDP (用户数据报协议)
```
特点：
- 无连接
- 不可靠传输
- 高效快速
- 支持广播
```

### 2.3 HTTP (超文本传输协议)
```
请求格式：
GET /index.html HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0
Accept: text/html

响应格式：
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 123

<html>...</html>
```

## 3. 网络编程基础概念

### 3.1 Socket通信
```cpp
// 服务器端
socket()    → 创建套接字
bind()      → 绑定地址
listen()    → 监听连接
accept()    → 接受连接
read()/write() → 数据传输
close()     → 关闭连接

// 客户端
socket()    → 创建套接字
connect()   → 连接服务器
read()/write() → 数据传输
close()     → 关闭连接
```

### 3.2 端口和IP地址
```cpp
struct sockaddr_in {
    short sin_family;         // AF_INET
    unsigned short sin_port;  // 端口号
    struct in_addr sin_addr;  // IP地址
    char sin_zero[8];        // 填充
};
```

### 3.3 字节序
```cpp
// 主机字节序转网络字节序
htons() - 16位整数
htonl() - 32位整数

// 网络字节序转主机字节序
ntohs() - 16位整数
ntohl() - 32位整数
```

## 4. 常见网络问题

### 4.1 超时处理
```cpp
// 设置超时选项
struct timeval tv;
tv.tv_sec = 5;  // 5秒超时
setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv));
```

### 4.2 并发处理
```cpp
// 多线程处理连接
std::thread([socket]() {
    handleClient(socket);
}).detach();
```

### 4.3 错误处理
```cpp
if (connect(sockfd, ...) < 0) {
    switch (errno) {
        case ETIMEDOUT: // 连接超时
        case ECONNREFUSED: // 连接被拒绝
        case ENETUNREACH: // 网络不可达
    }
}
```

这些是网络编程中最基础和最重要的概念，理解这些对于开发网络应用至关重要。

# socket
让我详细介绍 socket 的底层原理：

### 1. Socket 文件描述符

```cpp
serverSocket = socket(AF_INET, SOCK_STREAM, 0);
```

是的，这里返回的是一个文件描述符(File Descriptor)。在 Linux 中，socket 也被视为一个文件，这符合 "一切皆文件" 的理念。

### 2. Socket 底层原理

#### 2.1 分层结构
```
+-------------------+
|     应用层        |  HTTP, FTP, SSH 等
+-------------------+
|     传输层        |  TCP, UDP
+-------------------+
|     网络层        |  IP
+-------------------+
|     链路层        |  以太网等
+-------------------+
|     物理层        |  网线, 光纤等
+-------------------+
```

#### 2.2 数据流动过程
```
应用程序数据
    ↓
Socket 接口
    ↓
TCP/UDP 封装
    ↓
IP 封装
    ↓
网卡驱动
    ↓
物理传输
```

### 3. Socket 内核实现

#### 3.1 数据结构
```cpp
struct socket {
    struct sock *sk;         // 网络层协议相关
    struct file *file;       // 文件系统相关
    struct proto_ops *ops;   // 操作函数集
    // ...
};
```

#### 3.2 主要组件

1. **接收缓冲区(Receive Buffer)**：
```
+------------------+
|  待读取数据      |
+------------------+
     ↑
  网络数据到达
```

2. **发送缓冲区(Send Buffer)**：
```
+------------------+
|  待发送数据      |
+------------------+
     ↓
  向网络发送
```

### 4. Socket 通信过程

以 TCP 为例：

```
客户端                     服务器
   |                        |
   |       SYN=1           |
   |---------------------->|  
   |                      |
   |    SYN=1, ACK=1     |
   |<----------------------|
   |                      |
   |       ACK=1         |
   |---------------------->|
   |                      |
   |     数据传输         |
   |<-------------------->|
```

### 5. 系统调用过程

```cpp
// 1. 创建socket
int fd = socket(AF_INET, SOCK_STREAM, 0);
    |
    ↓
sys_socket()  // 内核系统调用
    |
    ↓
sock_create()  // 创建socket结构
    |
    ↓
sock_map_fd()  // 分配文件描述符
```

### 6. 重要特性

1. **双向通信**：
```cpp
struct socket_buffer {
    struct sk_buff *receive_queue;  // 接收队列
    struct sk_buff *write_queue;    // 发送队列
    // ...
};
```

2. **阻塞/非阻塞**：
```cpp
// 非阻塞设置
int flags = fcntl(sockfd, F_GETFL, 0);
fcntl(sockfd, F_SETFL, flags | O_NONBLOCK);
```

这种复杂的系统使得网络通信既高效又可靠，同时提供了简单的编程接口。每个 socket 都有其自己的发送和接收缓冲区，由内核管理，这就是为什么我们能够通过简单的文件操作来进行网络通信。

# TCP端口状态详解

TCP连接在生命周期中会经历以下几个主要状态：

### 1. LISTEN（监听状态）
```
+------------+
|  LISTEN    | ← 服务器等待连接
+------------+
```
- 服务器进程正在等待客户端连接请求
- `socket()`, `bind()`, `listen()` 后的状态

### 2. SYN_SENT（同步已发送）
```
+-----------+    SYN     +------------+
| SYN_SENT  | ---------> |            |
+-----------+            |  服务器端    |
```
- 客户端已发送连接请求，等待服务器确认
- 第一次握手状态

### 3. SYN_RECEIVED（同步已接收）
```
+---------------+    SYN-ACK    +------------+
| SYN_RECEIVED  | <----------- |  客户端     |
+---------------+              +------------+
```
- 服务器已收到连接请求，发送确认
- 第二次握手状态

### 4. ESTABLISHED（已建立连接）
```
+---------------+    数据传输    +------------+
| ESTABLISHED   | <-----------> | ESTABLISHED |
+---------------+              +------------+
```
- 连接已建立，可以进行数据传输
- 完成三次握手后的状态

### 5. FIN_WAIT_1（等待关闭）
```
+-------------+    FIN     +------------+
| FIN_WAIT_1  | ---------> |            |
+-------------+            |            |
```
- 主动关闭方发送FIN请求关闭连接
- 第一次挥手状态

### 6. CLOSE_WAIT（等待关闭）
```
+-------------+           +------------+
|             | <-------- | CLOSE_WAIT |
+-------------+    ACK    +------------+
```
- 被动关闭方发送ACK确认，等待应用程序关闭
- 第二次挥手状态

### 7. FIN_WAIT_2（等待FIN）
```
+-------------+           +------------+
| FIN_WAIT_2  |           |            |
+-------------+           +------------+
```
- 主动关闭方等待对方的FIN包
- 收到ACK后的状态

### 8. LAST_ACK（最后确认）
```
+-------------+    FIN     +------------+
|             | <-------- | LAST_ACK   |
+-------------+           +------------+
```
- 被动关闭方发送FIN
- 第三次挥手状态

### 9. TIME_WAIT（时间等待）
```
+------------+    2MSL     +------------+
| TIME_WAIT  | ---------> | CLOSED     |
+------------+    超时     +------------+
```
- 主动关闭方等待2MSL时间后关闭
- 目的：
  1. 确保最后的ACK能够到达对方
  2. 确保旧连接的数据包完全消失

### TIME_WAIT 问题
```cpp
// 设置SO_REUSEADDR选项解决TIME_WAIT问题
int opt = 1;
setsockopt(serverSocket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
```

这就是为什么我们在服务器代码中设置 `SO_REUSEADDR` 选项，它允许：
1. 在TIME_WAIT状态下重用端口
2. 服务器可以立即重启
3. 防止端口被长时间占用