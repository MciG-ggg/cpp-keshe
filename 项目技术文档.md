# 商场停车场管理系统技术文档

## 1. 系统架构概述

### 1.1 整体架构
系统采用前后端分离的架构设计：

- 前端：HTML + CSS + JavaScript
- 后端：C++ RESTful API服务器
- 数据存储：文件系统（parking_data.dat）

### 1.2 核心功能模块
- 车辆管理：入场、出场登记
- 费用计算：基于车型和停车时长
- 状态监控：实时车位统计
- 历史记录：停车记录查询

## 2. 前后端数据交互

### 2.1 API接口设计

#### 2.1.1 车辆入场
- 接口：POST /api/vehicle
- 请求数据：
```json
{
    "plate": "车牌号",
    "type": "车辆类型"
}
```
- 响应数据：
```json
{
    "success": true/false,
    "message": "操作结果描述"
}
```

#### 2.1.2 车辆出场
- 接口：DELETE /api/vehicle/{车牌号}
- 响应数据：
```json
{
    "success": true/false,
    "message": "操作结果描述",
    "data": {
        "plate": "车牌号",
        "type": "车辆类型",
        "fee": 费用金额
    }
}
```

#### 2.1.3 状态查询
- 接口：GET /api/status
- 响应数据：
```json
{
    "success": true,
    "data": {
        "available": 可用车位数,
        "occupied": 已占用车位数
    }
}
```

#### 2.1.4 历史记录查询
- 接口：GET /api/history
- 响应数据：
```json
{
    "success": true,
    "data": [
        {
            "plate": "车牌号",
            "type": "车辆类型",
            "entryTime": 入场时间戳,
            "exitTime": 出场时间戳,
            "fee": 费用金额
        }
    ]
}
```

### 2.2 前端实现细节

#### 2.2.1 API调用封装
前端通过 `api.js` 封装所有API调用：
```javascript
const ParkingAPI = {
    async addVehicle(plate, type) {
        // 发送POST请求处理车辆入场
    },
    async removeVehicle(plate) {
        // 发送DELETE请求处理车辆出场
    }
    // ...其他API封装
};
```

#### 2.2.2 实时数据更新
- 使用定时轮询更新停车场状态
- 采用事件监听处理用户操作
- 异步处理所有API请求

### 2.3 后端实现细节

#### 2.3.1 请求处理流程
1. 接收HTTP请求
2. 解析请求参数
3. 调用业务逻辑
4. 返回JSON响应

#### 2.3.2 并发处理
- 使用多线程处理并发请求
- 线程安全的数据访问控制
- 异常处理机制

## 3. 数据存储与读取

### 3.1 数据持久化方案

#### 3.1.1 文件存储结构
- 使用二进制文件 parking_data.dat 存储数据
- 包含车辆信息、费率设置等数据
- 采用序列化方式存储数据结构

#### 3.1.2 数据读写操作
- 程序启动时自动加载数据
- 数据变更时实时写入
- 程序退出时确保数据保存

### 3.2 数据安全性保障
- 文件操作异常处理
- 数据完整性校验
- 并发访问控制

### 3.3 数据备份机制
- 定期自动备份
- 数据恢复机制
- 日志记录功能

## 4. 系统优化与扩展

### 4.1 性能优化
- API响应时间优化
- 数据存取效率提升
- 内存使用优化

### 4.2 可扩展性设计
- 模块化的代码结构
- 可配置的系统参数
- 插件式的功能扩展

### 4.3 安全性增强
- 输入数据验证
- URL编码处理
- CORS跨域控制
- 异常处理机制

## 5. 调试与维护

### 5.1 调试工具
- 前端控制台调试
- API测试脚本
- 日志监控

### 5.2 常见问题处理
- 连接异常处理
- 数据同步问题
- 并发访问问题

## 6. 部署说明

### 6.1 环境要求
- Linux操作系统
- G++ 编译器 (C++17)
- Make构建工具

### 6.2 部署步骤
1. 编译后端服务
2. 配置服务参数
3. 启动服务程序
4. 访问Web界面

## 具体实现
让我通过查看代码来详细解释前后端数据交互和数据存储的具体实现。我来详细解释前后端数据交互和数据存储的具体实现：

1. **前端实现 (Frontend)**
- api.js 中封装了所有与后端的API交互，包括：
  ```javascript
  - addVehicle(plate, type)    // 车辆入场
  - removeVehicle(plate)       // 车辆出场
  - queryVehicle(plate)        // 查询车辆信息
  - getParkingStatus()         // 获取停车场状态
  - updateRates()              // 更新费率
  - getHistory()              // 获取历史记录
  ```
- 采用现代的 `async/await` 异步处理方式
- 统一的错误处理机制
- 所有请求都使用标准的 RESTful 风格

2. **后端实现 (Backend)**
在 api_server.cpp 中：
- 使用多线程处理并发请求
- 实现了完整的 HTTP 请求解析和响应生成
- 支持 CORS 跨域请求
- 支持静态文件服务

主要处理函数包括：
```cpp
- handleAddVehicle()      // 处理入场请求
- handleRemoveVehicle()   // 处理出场请求
- handleQueryVehicle()    // 处理查询请求
- handleGetParkingStatus() // 处理状态查询
- handleGetHistory()      // 处理历史记录查询
```

3. **数据存储实现**
- 采用二进制文件 parking_data.dat 进行持久化存储
- 文件操作设计：
  ```cpp
  - 程序启动时从文件加载数据
  - 数据变更时实时写入文件
  - 使用文件锁保证并发安全
  - 定期自动备份机制
  ```

4. **数据交互流程**
以车辆入场为例：
```
前端 → 后端 → 数据存储的完整流程：
1. 用户在前端输入车牌号和车型
2. api.js 中的 addVehicle() 发送 POST 请求
3. 后端 api_server.cpp 接收并解析请求
4. parking_lot.cpp 处理业务逻辑
5. 数据写入 parking_data.dat
6. 返回处理结果给前端
7. 前端更新界面显示
```

5. **安全性设计**
- URL编码处理防止注入
- 输入数据验证
- CORS安全控制
- 文件操作异常处理
- 并发访问控制

这个项目采用了现代化的前后端分离架构，数据交互清晰，存储机制可靠，并考虑了并发、安全等关键因素。完整的API接口设计和数据持久化方案使系统具有良好的可扩展性和可维护性。

---
# 各模块语法

---
# JavaScript 异步函数语法解析

## 1. 异步函数声明
```javascript
async addVehicle(plate, type)
```
- `async`: 声明这是一个异步函数，允许在函数内使用 `await` 关键字
- `addVehicle`: 函数名
- `plate, type`: 函数参数，分别接收车牌号和车型

## 2. Fetch API 调用
```javascript
const response = await fetch(`${CONFIG.API_BASE_URL}/vehicle`, {
    method: 'POST',
    headers: {
        'Content-Type': 'application/json',
    },
    body: JSON.stringify({ plate, type })
});
```
- ```${CONFIG.API_BASE_URL}```: 模板字符串语法，用于动态拼接API地址
- `fetch()`: 浏览器原生的网络请求API
- `await`: 等待异步操作完成
- 请求配置对象包含：
  - `method: 'POST'`: HTTP请求方法
  - `headers`: 设置请求头
  - `body`: 请求体，使用`JSON.stringify()`将对象转换为JSON字符串

## 3. 错误处理
```javascript
try {
    // 请求代码
} catch (error) {
    console.error('Error adding vehicle:', error);
    throw error;
}
```
- `try/catch`: 异常捕获语法
- `console.error()`: 在控制台输出错误信息
- `throw error`: 向上层抛出错误

## 4. 响应处理
```javascript
return await response.json();
```
- `response.json()`: 将响应解析为JSON对象
- `await`: 等待解析完成
- `return`: 返回解析后的数据

## 实际使用示例
```javascript
// 调用示例
try {
    const result = await ParkingAPI.addVehicle('京A12345', 'small');
    console.log('车辆添加成功:', result);
} catch (error) {
    console.error('车辆添加失败:', error);
}
```

---
# JavaScript Fetch API 详解

Fetch API 是现代浏览器提供的一种原生网络请求接口，用于替代传统的 XMLHttpRequest。它提供了一个更简单、更强大的方式来进行网络请求。

## 1. 基本用法
```javascript
fetch(url, options)
  .then(response => response.json())
  .catch(error => console.error('Error:', error));
```

## 2. 主要特点

1. **Promise 基础**
- 返回 Promise 对象
- 支持 async/await 语法
- 链式调用处理响应

2. **请求配置选项**
```javascript
const options = {
    method: 'POST',          // 请求方法
    headers: {               // 请求头
        'Content-Type': 'application/json'
    },
    body: JSON.stringify(data), // 请求体
    mode: 'cors',           // 跨域模式
    credentials: 'include', // 凭证处理
}
```

3. **响应处理方法**
```javascript
response.json()    // 解析JSON响应
response.text()    // 获取文本响应
response.blob()    // 处理二进制数据
response.formData() // 处理表单数据
```

## 3. 实际应用示例

### GET 请求
```javascript
// 基本GET请求
fetch('https://api.example.com/data')
    .then(response => response.json())
    .then(data => console.log(data));

// 带参数的GET请求
fetch('https://api.example.com/data?id=123')
    .then(response => response.json());
```

### POST 请求
```javascript
fetch('https://api.example.com/data', {
    method: 'POST',
    headers: {
        'Content-Type': 'application/json',
    },
    body: JSON.stringify({
        name: 'test',
        value: 123
    })
});
```

### 使用 async/await
```javascript
async function getData() {
    try {
        const response = await fetch('https://api.example.com/data');
        const data = await response.json();
        return data;
    } catch (error) {
        console.error('Error:', error);
    }
}
```

## 4. 错误处理
- fetch 只有在网络错误时才会 reject
- HTTP 错误状态（如 404）不会导致 reject
- 需要手动检查 response.ok 或 response.status

```javascript
fetch('https://api.example.com/data')
    .then(response => {
        if (!response.ok) {
            throw new Error('HTTP错误，状态码: ' + response.status);
        }
        return response.json();
    })
    .catch(error => console.error('错误:', error));
```

## 5. 与 XMLHttpRequest 比较
- Fetch 语法更简洁
- 基于 Promise，支持链式调用
- 更好的模块化支持
- 原生支持 JSON
- 更强大的请求控制能力

---
## 后端相关(api_server.cpp)
好的,我来详细讲解后端相关的关键文件和涉及的知识。首先让我查看主要的后端文件：让我详细讲解后端的关键文件和重要知识点：

1. **API服务器实现 (api_server.cpp/h)**
- HTTP服务器的核心实现，包含以下关键知识：

```cpp
class ParkingApiServer {
    // Socket编程基础
    int serverSocket;  // 服务器socket
    bool running;      // 服务器运行状态
    
    // 智能指针管理资源
    std::unique_ptr<ParkingLot> parkingLot;
    
    // API路由处理函数
    HttpResponse handleAddVehicle(const HttpRequest& req);
    HttpResponse handleRemoveVehicle(const HttpRequest& req);
    // ...其他处理函数
};
```

重要知识点：
- Socket网络编程：创建socket、绑定端口、监听连接
- 多线程并发处理：每个客户端请求都在新线程中处理
- HTTP协议实现：请求解析、响应生成
- CORS跨域处理：设置跨域头部
- 异常处理：try-catch错误处理机制
- 智能指针：使用unique_ptr管理资源

2. **停车场业务逻辑 (parking_lot.cpp/h)**
核心业务类，处理：
- 车辆管理（增删改查）
- 费用计算
- 数据持久化

重要知识点：
- STL容器使用：
```cpp
std::map<std::string, Vehicle> vehicles;  // 存储车辆信息
std::vector<Vehicle> getHistoryVehicles() const;  // 返回历史记录
```
- 文件IO操作：二进制文件读写
- const成员函数：保证数据安全
- 数据序列化：对象持久化到文件

3. **数据持久化实现**
在parking_lot.cpp中：
```cpp
bool ParkingLot::saveData() const {
    std::ofstream outFile(dataFilePath, std::ios::binary);
    // 写入元数据（容量、费率等）
    // 写入车辆数据
}

bool ParkingLot::loadData() {
    std::ifstream inFile(dataFilePath, std::ios::binary);
    // 读取元数据
    // 读取车辆数据
}
```

重要知识点：
- 二进制文件操作
- 数据序列化/反序列化
- 类型安全的数据读写

4. **线程安全考虑**
```cpp
std::thread([this, clientSocket]() {
    // 在新线程中处理请求
    try {
        HttpRequest request = parseRequest(clientSocket);
        // 处理请求...
    } catch (...) {
        // 错误处理
    }
}).detach();
```

重要知识点：
- 多线程编程
- Lambda表达式
- RAII资源管理
- 异常安全

5. **C++11/17特性使用**
- 智能指针
- Lambda表达式
- 文件系统操作(std::filesystem)
- 范围for循环
- auto类型推导

6. **HTTP协议实现**
```cpp
class HttpRequest {
    std::string method;     // GET, POST等
    std::string path;       // 请求路径
    std::string body;       // 请求体
    std::map<std::string, std::string> params;  // 请求参数
};

class HttpResponse {
    int status;            // 状态码
    std::string body;      // 响应体
    std::map<std::string, std::string> headers;  // 响应头
};
```

这个实现展示了：
- HTTP协议的基本概念
- RESTful API设计
- 请求/响应的处理流程
- 错误处理机制

要掌握这个项目的后端实现，需要理解：
1. C++面向对象编程
2. STL容器和算法
3. 网络编程基础（Socket）
4. HTTP协议
5. 多线程编程
6. 文件IO操作
7. 现代C++特性

这些知识点相互关联，共同构成了一个完整的后端服务器系统。建议从基础的C++知识开始，逐步深入学习网络编程和多线程等高级主题。